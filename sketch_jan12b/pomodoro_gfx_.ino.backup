// Arduino_GFX-based Pomodoro timer for Waveshare ESP32-C6-LCD-1.47
// Uses the golden "R" in a circle as the splash / stopped screen.

#include <Arduino_GFX_Library.h>
#include "FreeSansBold24pt7b.h"  // Smooth font for the logo and titles

// Backlight pin (official: GPIO23 = LCD_BL)
#define GFX_BL 23

// Rotation (0 = portrait, like official demo)
#define ROTATION 0

// Official pins from ESP32-C6-Touch-LCD-1.47 scheme:
// LCD_CLK = GPIO1, LCD_DIN = GPIO2, LCD_CS = GPIO14, LCD_DC = GPIO15, LCD_RST = GPIO22
Arduino_DataBus *bus = new Arduino_HWSPI(15 /* DC */, 14 /* CS */, 1 /* SCK */, 2 /* MOSI */);

Arduino_GFX *gfx = new Arduino_ST7789(
  bus, 22 /* RST */, 0 /* rotation */, false /* IPS */,
  172 /* width */, 320 /* height */,
  34 /*col_offset1*/, 0 /*uint8_t row_offset1*/,
  34 /*col_offset2*/, 0 /*row_offset2*/);

// --- Low-level LCD init from Waveshare demo (unchanged) ---
void lcd_reg_init(void) {
  static const uint8_t init_operations[] = {
    BEGIN_WRITE,
    WRITE_COMMAND_8, 0x11,
    END_WRITE,
    DELAY, 120,

    BEGIN_WRITE,
    WRITE_C8_D16, 0xDF, 0x98, 0x53,
    WRITE_C8_D8, 0xB2, 0x23,

    WRITE_COMMAND_8, 0xB7,
    WRITE_BYTES, 4,
    0x00, 0x47, 0x00, 0x6F,

    WRITE_COMMAND_8, 0xBB,
    WRITE_BYTES, 6,
    0x1C, 0x1A, 0x55, 0x73, 0x63, 0xF0,

    WRITE_C8_D16, 0xC0, 0x44, 0xA4,
    WRITE_C8_D8, 0xC1, 0x16,

    WRITE_COMMAND_8, 0xC3,
    WRITE_BYTES, 8,
    0x7D, 0x07, 0x14, 0x06, 0xCF, 0x71, 0x72, 0x77,

    WRITE_COMMAND_8, 0xC4,
    WRITE_BYTES, 12,
    0x00, 0x00, 0xA0, 0x79, 0x0B, 0x0A, 0x16, 0x79, 0x0B, 0x0A, 0x16, 0x82,

    WRITE_COMMAND_8, 0xC8,
    WRITE_BYTES, 32,
    0x3F, 0x32, 0x29, 0x29, 0x27, 0x2B, 0x27, 0x28, 0x28, 0x26, 0x25, 0x17, 0x12, 0x0D, 0x04, 0x00,
    0x3F, 0x32, 0x29, 0x29, 0x27, 0x2B, 0x27, 0x28, 0x28, 0x26, 0x25, 0x17, 0x12, 0x0D, 0x04, 0x00,

    WRITE_COMMAND_8, 0xD0,
    WRITE_BYTES, 5,
    0x04, 0x06, 0x6B, 0x0F, 0x00,

    WRITE_C8_D16, 0xD7, 0x00, 0x30,
    WRITE_C8_D8, 0xE6, 0x14,
    WRITE_C8_D8, 0xDE, 0x01,

    WRITE_COMMAND_8, 0xB7,
    WRITE_BYTES, 5,
    0x03, 0x13, 0xEF, 0x35, 0x35,

    WRITE_COMMAND_8, 0xC1,
    WRITE_BYTES, 3,
    0x14, 0x15, 0xC0,

    WRITE_C8_D16, 0xC2, 0x06, 0x3A,
    WRITE_C8_D16, 0xC4, 0x72, 0x12,
    WRITE_C8_D8, 0xBE, 0x00,
    WRITE_C8_D8, 0xDE, 0x02,

    WRITE_COMMAND_8, 0xE5,
    WRITE_BYTES, 3,
    0x00, 0x02, 0x00,

    WRITE_COMMAND_8, 0xE5,
    WRITE_BYTES, 3,
    0x01, 0x02, 0x00,

    WRITE_C8_D8, 0xDE, 0x00,
    WRITE_C8_D8, 0x35, 0x00,
    WRITE_C8_D8, 0x3A, 0x05,

    WRITE_COMMAND_8, 0x2A,
    WRITE_BYTES, 4,
    0x00, 0x22, 0x00, 0xCD,

    WRITE_COMMAND_8, 0x2B,
    WRITE_BYTES, 4,
    0x00, 0x00, 0x01, 0x3F,

    WRITE_C8_D8, 0xDE, 0x02,

    WRITE_COMMAND_8, 0xE5,
    WRITE_BYTES, 3,
    0x00, 0x02, 0x00,

    WRITE_C8_D8, 0xDE, 0x00,
    WRITE_C8_D8, 0x36, 0x00,
    WRITE_COMMAND_8, 0x21,
    END_WRITE,

    DELAY, 10,

    BEGIN_WRITE,
    WRITE_COMMAND_8, 0x29,
    END_WRITE
  };
  bus->batchOperation(init_operations, sizeof(init_operations));
}

// --- Color scheme (minimalistic black & gold + blue for rest) ---
const uint16_t COLOR_BLACK = 0x0000;
const uint16_t COLOR_GOLD  = 0xFCE0; // tuned golden
const uint16_t COLOR_BLUE  = 0x001F;

// --- Pomodoro logic (adapted from pomodoro_timer.ino) ---
enum TimerState {
  STOPPED,
  RUNNING,
  PAUSED
};

const unsigned long POMODORO_DURATION = 25UL * 60UL * 1000UL; // 25 minutes
const unsigned long FLASH_DURATION    = 500;                  // ms
const unsigned long LONG_PRESS_MS     = 1000;                 // long press

// Touch: board actually uses I2C touch, здесь оставляем GPIO-заглушку
#define TOUCH_PIN 9
#define TOUCH_THRESHOLD 40

TimerState currentState = STOPPED;
unsigned long startTime = 0;
unsigned long pausedTime = 0;
unsigned long elapsedBeforePause = 0;
bool isWorkSession = true;
bool flashActive = false;
unsigned long flashStartTime = 0;
uint16_t flashColor = COLOR_GOLD;

bool touchPressed = false;
unsigned long touchStartTime = 0;
bool longPressDetected = false;

// --- Helper: draw golden "R" splash (used as stopped screen) ---
void drawSplash() {
  gfx->fillScreen(COLOR_BLACK);

  uint16_t golden = COLOR_GOLD;
  int16_t centerX = gfx->width() / 2;
  int16_t centerY = gfx->height() / 2;
  int16_t radius = 60;
  int16_t borderWidth = 5;

  for (int16_t i = 0; i < borderWidth; i++) {
    gfx->drawCircle(centerX, centerY, radius - i, golden);
  }

  gfx->setFont(&FreeSansBold24pt7b);
  gfx->setTextColor(golden);
  gfx->setTextSize(2, 2, 0);
  gfx->setCursor(centerX - 33, centerY + 30); // отцентровано под твой экран
  gfx->print("R");
}

// --- Helper: centered text using getTextBounds ---
void drawCenteredText(const char *txt, int16_t cx, int16_t cy, uint16_t color, uint8_t size) {
  int16_t x1, y1;
  uint16_t w, h;
  gfx->setFont(nullptr);           // стандартный шрифт для таймера
  gfx->setTextSize(size, size, 0);
  gfx->getTextBounds(txt, 0, 0, &x1, &y1, &w, &h);
  int16_t x = cx - (int16_t)w / 2;
  int16_t y = cy + (int16_t)h / 2;
  gfx->setCursor(x, y);
  gfx->setTextColor(color);
  gfx->print(txt);
}

// --- Pomodoro control functions ---
void triggerFlash(uint16_t color) {
  flashActive = true;
  flashColor = color;
  flashStartTime = millis();
}

void displayStoppedState(); // forward
void drawTimer();           // forward
void drawProgressCircle(float progress);

void startTimer() {
  currentState = RUNNING;
  isWorkSession = true;
  startTime = millis();
  elapsedBeforePause = 0;
  triggerFlash(COLOR_GOLD);
}

void pauseTimer() {
  if (currentState == RUNNING) {
    currentState = PAUSED;
    pausedTime = millis();
    elapsedBeforePause = millis() - startTime;
  }
}

void resumeTimer() {
  if (currentState == PAUSED) {
    currentState = RUNNING;
    startTime = millis() - elapsedBeforePause;
  }
}

void stopTimer() {
  currentState = STOPPED;
  displayStoppedState();
}

void updateTimer() {
  if (currentState == RUNNING) {
    unsigned long elapsed = millis() - startTime;
    if (elapsed >= POMODORO_DURATION) {
      if (isWorkSession) {
        isWorkSession = false;
        triggerFlash(COLOR_BLUE);
        startTime = millis();
      } else {
        isWorkSession = true;
        triggerFlash(COLOR_GOLD);
        startTime = millis();
      }
    }
  }
}

void handleTouchInput() {
  // TODO: заменить на реальный I2C touch; сейчас заглушка через analogRead
  int touchValue = analogRead(TOUCH_PIN);
  bool currentlyTouched = (touchValue < TOUCH_THRESHOLD);

  if (currentlyTouched && !touchPressed) {
    touchPressed = true;
    touchStartTime = millis();
    longPressDetected = false;
  } else if (!currentlyTouched && touchPressed) {
    unsigned long touchDuration = millis() - touchStartTime;

    if (longPressDetected) {
      if (currentState == STOPPED) {
        startTimer();
      } else {
        stopTimer();
      }
    } else if (touchDuration > 50) {
      if (currentState == RUNNING) {
        pauseTimer();
      } else if (currentState == PAUSED) {
        resumeTimer();
      }
    }

    touchPressed = false;
    longPressDetected = false;
  } else if (touchPressed && !longPressDetected) {
    if (millis() - touchStartTime > LONG_PRESS_MS) {
      longPressDetected = true;
    }
  }
}

void updateDisplay() {
  if (flashActive) {
    if (millis() - flashStartTime < FLASH_DURATION) {
      gfx->fillScreen(flashColor);
    } else {
      flashActive = false;
      if (currentState == STOPPED) {
        displayStoppedState();
      } else {
        drawTimer();
      }
    }
    return;
  }

  if (currentState == STOPPED) {
    return;
  } else {
    drawTimer();
  }
}

void drawTimer() {
  gfx->fillScreen(COLOR_BLACK);

  unsigned long elapsed = 0;
  if (currentState == RUNNING) {
    elapsed = millis() - startTime;
  } else if (currentState == PAUSED) {
    elapsed = elapsedBeforePause;
  }

  unsigned long remaining = (elapsed >= POMODORO_DURATION) ? 0 : (POMODORO_DURATION - elapsed);
  unsigned long minutes = remaining / 60000UL;
  unsigned long seconds = (remaining % 60000UL) / 1000UL;

  char timeStr[6];
  sprintf(timeStr, "%02lu:%02lu", minutes, seconds);

  drawCenteredText(timeStr, gfx->width() / 2, gfx->height() / 2 - 20, COLOR_GOLD, 3);

  float progress = (float)elapsed / (float)POMODORO_DURATION;
  if (progress < 0) progress = 0;
  if (progress > 1) progress = 1;
  drawProgressCircle(progress);

  const char *statusTxt = nullptr;
  uint16_t statusColor = COLOR_GOLD;
  if (currentState == PAUSED) {
    statusTxt = "PAUSED";
  } else if (isWorkSession) {
    statusTxt = "WORK";
  } else {
    statusTxt = "REST";
    statusColor = COLOR_BLUE;
  }
  drawCenteredText(statusTxt, gfx->width() / 2, gfx->height() - 30, statusColor, 1);
}

void drawProgressCircle(float progress) {
  int centerX = gfx->width() / 2;
  int centerY = gfx->height() / 2 + 40;
  int radius = 30;

  gfx->drawCircle(centerX, centerY, radius, COLOR_GOLD);

  if (progress > 0 && progress <= 1.0f) {
    const int segments = 32;
    for (int i = 0; i < segments * progress; i++) {
      float angle = (i * 2.0f * PI) / segments - PI / 2.0f;
      int x = centerX + radius * cosf(angle);
      int y = centerY + radius * sinf(angle);
      gfx->drawPixel(x, y, COLOR_GOLD);
    }
  }
}

void displayStoppedState() {
  drawSplash();
}

// --- Arduino setup / loop ---
void setup(void) {
  Serial.begin(115200);
  Serial.println("Pomodoro Timer (Arduino_GFX) starting...");

  if (!gfx->begin()) {
    Serial.println("gfx->begin() failed!");
  }

  lcd_reg_init();
  gfx->setRotation(ROTATION);

  gfx->fillScreen(COLOR_BLACK);

#ifdef GFX_BL
  pinMode(GFX_BL, OUTPUT);
  digitalWrite(GFX_BL, HIGH);
#endif

  displayStoppedState();
}

void loop() {
  handleTouchInput();
  updateTimer();
  updateDisplay();
  delay(10);
}
